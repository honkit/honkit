---
author: azu
description: "JavaScriptの値の種類にあたるデータ型についてを紹介します。データ型には大きく分けてプリミティブ型とオブジェクトがあり、それぞれのデータ型を簡単なコード例とともに紹介していきます。一部のデータ型にはリテラルというデータ型を簡単に記述するための構文が用意されており、リテラルについても合わせて紹介していきます。"
---

# データ型とリテラル {#data-type-and-literal}

## データ型 {#data-type}

JavaScriptは動的型付け言語に分類される言語であるため、静的型付け言語のような**変数の型**はありません。
しかし、文字列、数値、真偽値といった**値の型**は存在します。
これらの値の型のことを**データ型**と呼びます。

データ型を大きく分けると、**プリミティブ型**と**オブジェクト**の2つに分類されます。

プリミティブ型（基本型）は、真偽値や数値などの基本的な値の型のことです。
プリミティブ型の値は、一度作成したらその値自体を変更できないというイミュータブル（immutable）の特性を持ちます。
JavaScriptでは、文字列も一度作成したら変更できないイミュータブルの特性を持ち、プリミティブ型の一種として扱われます。

一方、プリミティブ型ではないものをオブジェクト（複合型）と呼び、
オブジェクトは複数のプリミティブ型の値またはオブジェクトからなる集合です。
オブジェクトは、一度作成した後もその値自体を変更できるためミュータブル（mutable）の特性を持ちます。
オブジェクトは、値そのものではなく値への参照を経由して操作されるため、参照型のデータとも言います。

データ型を細かく見ていくと、6つのプリミティブ型とオブジェクトからなります。

- プリミティブ型（基本型）
    - 真偽値（Boolean）: `true`または`false`のデータ型
    - 数値（Number）: `42` や `3.14159` などの数値のデータ型
    - 文字列（String）: `"JavaScript"` などの文字列のデータ型
    - undefined: 値が未定義であることを意味するデータ型
    - null: 値が存在しないことを意味するデータ型
    - シンボル（Symbol）: ES2015から追加された一意で不変な値のデータ型
- オブジェクト（複合型）
    - プリミティブ型以外のデータ
    - オブジェクト、配列、関数、正規表現、Dateなど

プリミティブ型でないものは、オブジェクトであると覚えていれば問題ありません。

`typeof`演算子を使うことで、次のようにデータ型を調べることができます。

{{book.console}}
```js
console.log(typeof true);// => "boolean"
console.log(typeof 42); // => "number"
console.log(typeof "JavaScript"); // => "string"
console.log(typeof Symbol("シンボル"));// => "symbol"
console.log(typeof undefined); // => "undefined"
console.log(typeof null); // => "object"
console.log(typeof ["配列"]); // => "object"
console.log(typeof { "key": "value" }); // => "object"
console.log(typeof function() {}); // => "function"
```

残念ながら`typeof null`が`"object"`となるのは、歴史的経緯のある仕様のバグ[^1]です。
他のプリミティブ型の値については、`typeof`演算子でそれぞれのデータ型を調べることができます。

一方で、配列とオブジェクトがどちらも`"object"`という判定結果になります。
このように、`typeof`演算子ではすべてのオブジェクトの種類を判定することはできません。

基本的に`typeof`演算子は、プリミティブ型またはオブジェクトかを判別するものです。
オブジェクトの詳細な種類を判定できないことは、覚えておくとよいでしょう。
各オブジェクトの判定方法については、それぞれのオブジェクトの章で見ていきます。

## リテラル {#literal}

プリミティブ型の値や一部のオブジェクトは、**リテラル**を使うことで簡単に定義できるようになっています。

リテラルとはプログラム上で数値や文字列など、データ型の値を直接記述できるように構文として定義されたものです。
たとえば、`"`と`"`で囲んだ範囲が文字列リテラルで、これは文字列型のデータを表現しています。

次のコードでは、`"こんにちは"`という文字列型のデータを初期値に持つ変数`str`を定義しています。

```js
// "と"で囲んだ範囲が文字列リテラル
const str = "こんにちは";
```

リテラル表現がない場合は、その値を作る関数に引数を渡して作成する形になります。
そのような冗長な表現を避ける方法として、よく利用される主要な値にはリテラルが用意されています。

次の4つのプリミティブ型は、それぞれリテラル表現を持っています。

- 真偽値
- 数値
- 文字列
- null

また、オブジェクトの中でもよく利用されるものに関してはリテラル表現が用意されています。

- オブジェクト
- 配列
- 正規表現

これらのリテラルについて、まずはプリミティブ型から順番に見ていきます。

### 真偽値（Boolean）{#boolean}

真偽値には`true`と`false`のリテラルがあります。
それぞれは`true`と`false`の値を返すリテラルで、見た目どおりの意味となります。

{{book.console}}
```js
true; // => true
false; // => false
```

### 数値（Number）{#number}

数値は大きく分けて`42`のような整数リテラルと`3.14159`のような浮動小数点数リテラルがあります。

#### 整数リテラル {#integer-literal}

整数リテラルには次の4種類があります。

<!-- textlint-disable preset-ja-technical-writing/no-doubled-joshi -->

- 10進数: 数字の組み合わせ
    - ただし、複数の数字を組み合わせた際に、先頭を`0`から開始すると8進数として扱われる場合があります
    - 例）`0`、`2`、`10`
- 2進数: `0b`（または`0B`）の後ろに、`0`または`1`の数字の組み合わせ
    - 例）`0b0`、`0b10`、`0b1010`
- 8進数: `0o`（または`0O`）の後ろに、`0`から`7`までの数字の組み合わせ
    - `0o` は数字のゼロと小文字アルファベットの`o`
    - 例）`0o644`、`0o777`
- 16進数: `0x`（または`0X`）の後ろに、`0`から`9`までの数字と`a`から`f`または`A`から`F`のアルファベットの組み合わせ
    - アルファベットの大文字・小文字の違いは値には影響しません
    - 例）`0x30A2`、`0xEEFF`

<!-- textlint-enable preset-ja-technical-writing/no-doubled-joshi -->

0から9の数字のみで書かれた数値は、10進数として扱われます。

{{book.console}}
```js
console.log(1); // => 1
console.log(10); // => 10
console.log(255); // => 255
```

`0b`からはじまる2進数リテラルは、ビットを表現するのによく利用されています。
`b`は2進数を表すbinaryを意味しています。

<!-- 具体的な言及はないけどSyntaxを参照: https://tc39.es/ecma262/#prod-BinaryIntegerLiteral -->

{{book.console}}
```js
console.log(0b1111); // => 15
console.log(0b10000000000); // => 1024
```

`0o`からはじまる8進数リテラルは、ファイルのパーミッションを表現するのによく利用されています。
`o`は8進数を表すoctalを意味しています。

<!-- https://tc39.es/ecma262/#prod-OctalIntegerLiteral -->

{{book.console}}
```js
console.log(0o644);  // => 420
console.log(0o777);  // => 511
```

次のように、`0`からはじまり、`0`から`7`の数字を組み合わせた場合も8進数として扱われます。
しかし、この表記は10進数と紛らわしいものであったため、ES2015で`0o`の8進数リテラルが新たに導入されました。
また、strict modeではこの書き方は例外が発生するため、次のような8進数の書き方は避けるべきです。

{{book.console}}
[import, octal-legacy-literal-invalid.js](./src/octal-legacy-literal-invalid.js)

`0x`からはじまる16進数リテラルは、文字のコードポイントやRGB値の表現などに利用されています。
`x`は16進数を表すhexを意味しています。

<!-- https://tc39.es/ecma262/#prod-HexIntegerLiteral -->

{{book.console}}
```js
console.log(0xFF); // => 255
// 小文字で書いても意味は同じ
console.log(0xff); // => 255
console.log(0x30A2); // => 12450
```

| 名前      | 表記例 	| 用途                       |
|--------	|--------	|----------------------------|
| 10進数 	| 42     	| 数値                        |
| 2進数  	| 0b0001 	| ビット演算など               |
| 8進数  	| 0o777  	| ファイルのパーミッションなど     |
| 16進数 	| 0xEEFF 	| 文字のコードポイント、RGB値など         |

#### 浮動小数点数リテラル {#floating-point-number-literal}

JavaScriptの浮動小数点数は[IEEE 754][]を採用しています。
浮動小数点数をリテラルとして書く場合には、次の2種類の表記が利用できます。

- `3.14159` のような `.`（ドット）を含んだ数値
- `2e8` のような `e` または `E` を含んだ数値

`0`からはじまる浮動小数点数は、`0`を省略して書くことができます。

{{book.console}}
```js
.123; // => 0.123
```

しかし、JavaScriptでは`.`をオブジェクトにおいて利用する機会が多いため、
`0`からはじまる場合でも省略せずに書いたほうが意図しない挙動を減らせるでしょう。

> **Note** 変数名を数字からはじめることができないのは、数値リテラルと衝突してしまうからです。

`e`は指数（exponent）を意味する記号で、`e`のあとには指数部の値を書きます。
たとえば、`2e8`は2×10の8乗となるので、10進数で表すと`200000000`となります。

{{book.console}}
```js
2e8; // => 200000000
```

### 文字列（String）{#string}

文字列リテラル共通のルールとして、同じ記号で囲んだ内容を文字列として扱います。
文字列リテラルとして次の3種類のリテラルがありますが、その評価結果はすべて同じ`"文字列"`になります。

<!-- textlint-disable eslint -->

{{book.console}}
```js
console.log("文字列"); // => "文字列"
console.log('文字列'); // => "文字列"
console.log(`文字列`); // => "文字列"
```

<!-- textlint-enable eslint -->

#### ダブルクォートとシングルクォート {#double-quote-and-single-quote}

`"`（ダブルクォート）と`'`（シングルクォート）はまったく同じ意味となります。
PHPやRubyなどとは違い、どちらのリテラルでも評価結果は同じとなります。

文字列リテラルは同じ記号で囲む必要があるため、次のように文字列の中に同じ記号が出現した場合は、
`\'`のように`\`（バックスラッシュ）を使ってエスケープしなければなりません。

<!-- textlint-disable eslint -->

{{book.console}}
```js
'8 o\'clock'; // => "8 o'clock"
```

<!-- textlint-enable eslint -->

また、文字列内部に出現しない別のクォート記号を使うことで、エスケープをせずに書くこともできます。

{{book.console}}
```js
"8 o'clock"; // => "8 o'clock"
```

ダブルクォートとシングルクォートどちらも、改行をそのままでは入力できません。
次のように改行を含んだ文字列は定義できないため、構文エラー（`SyntaxError`）となります。

[import, multiple-line-string-invalid.js](src/multiple-line-string-invalid.js)

改行の代わりに改行記号のエスケープシーケンス（`\n`）を使うことで複数行の文字列を書くことができます。

{{book.console}}
```js
"複数行の\n文字列を\n入れたい";
```

シングルクォートとダブルクォートの文字列リテラルに改行を入れるには、エスケープシーケンスを使わないといけません。
これに対してES2015から導入されたテンプレートリテラルでは、複数行の文字列を直感的に書くことができます。

#### [ES2015] テンプレートリテラル {#template-literal}

テンプレートリテラルは `` ` ``（バッククォート）で囲んだ範囲を文字列とするリテラルです。
テンプレートリテラルでは、複数行の文字列を改行記号のエスケープシーケンス（`\n`）を使わずにそのまま書くことができます。

複数行の文字列も`` ` ``で囲めば、そのまま書くことができます。

{{book.console}}
```js
`複数行の
文字列を
入れたい`; // => "複数行の\n文字列を\n入れたい"
```

また、名前のとおりテンプレートのような機能も持っています。
テンプレートリテラル内で`${変数名}`と書いた場合に、その変数の値を埋め込むことができます。

{{book.console}}
```js
const str = "文字列";
console.log(`これは${str}です`); // => "これは文字列です"
```

テンプレートリテラルも他の文字列リテラルと同様に同じリテラル記号を内包したい場合は、`\`を使ってエスケープする必要があります。

<!-- textlint-disable eslint -->

{{book.console}}
```js
`This is \`code\``;// => "This is `code`"
```

<!-- textlint-enable eslint -->

### nullリテラル {#null-literal}

nullリテラルは`null`値を返すリテラルです。
`null`は「値がない」ということを表現する値です。

次のように、未定義の変数を参照した場合は、
参照できないため`ReferenceError`の例外が投げられます。

<!-- doctest: ReferenceError -->
```js
foo;// "ReferenceError: foo is not defined"
```

`foo`には値がないということを表現したい場合は、
`null`値を代入することで、`null`値を持つ`foo`という変数を定義できます。
これにより、`foo`を値がない変数として定義し、参照できるようになります。

{{book.console}}
```js
const foo = null;
console.log(foo); // => null
```

## [コラム] undefinedはリテラルではない {#undefined-is-not-literal}

プリミティブ型として紹介した`undefined`はリテラルではありません。
`undefined`はただのグローバル変数で、`undefined`という値を持っているだけです。

次のように、`undefined`はただのグローバル変数であるため、同じ`undefined`という名前のローカル変数を宣言できます。

<!-- textlint-disable eslint -->

{{book.console}}
```js
function fn(){
    var undefined = "独自の未定義値"; // undefinedという名前の変数をエラーなく定義できる
    console.log(undefined); // => "独自の未定義値"
}
fn();
```

<!-- textlint-enable eslint -->

これに対して`true`、`false`、`null`などはグローバル変数ではなくリテラルであるため、同じ名前の変数を定義することはできません。
リテラルは変数名として利用できない予約語のようなものであるため、再定義しようとすると構文エラー（SyntaxError）となります。

{{book.console}}
[import, var-null-invalid.js](./src/var-null-invalid.js)

ここでは、説明のために`undefined`というローカル変数を宣言しましたが、`undefined`の再定義は非推奨です。
無用な混乱を生むだけなので避けるべきです。

### オブジェクトリテラル {#object}

JavaScriptにおいて、オブジェクトはあらゆるものの基礎となります。
そのオブジェクトを作成する方法として、オブジェクトリテラルがあります。
オブジェクトリテラルは`{}`（中カッコ）を書くことで、新しいオブジェクトを作成できます。

```js
const obj = {}; // 中身が空のオブジェクトを作成
```

オブジェクトリテラルはオブジェクトの作成と同時に中身を定義できます。
オブジェクトのキーと値を`:`で区切ったものを `{}` の中に書くことで作成と初期化が同時に行えます。

次のコードで作成したオブジェクトは `key` というキー名と `value` という値を持つオブジェクトを作成しています。
キー名には、文字列またはSymbolを指定し、値にはプリミティブ型の値からオブジェクトまで何でも入れることができます。

```js
const obj = {
    "key": "value"
};
```

このとき、オブジェクトが持つキーのことをプロパティ名と呼びます。
この場合、 `obj`というオブジェクトは`key`というプロパティを持っていると言います。

`obj`の`key`プロパティを参照するには、`.`（ドット）でつないで参照する方法と、
`[]`（ブラケット）で参照する方法があります。

{{book.console}}
```js
const obj = {
    "key": "value"
};
// ドット記法
console.log(obj.key); // => "value"
// ブラケット記法
console.log(obj["key"]); // => "value"
```

ドット記法では、プロパティ名が変数名と同じく識別子である必要があります。
そのため、次のように識別子として利用できないプロパティ名はドット記法として書くことができません。

{{book.console}}
```Js
// プロパティ名は文字列の"123"
var object = {
    "123": "value"
};
// OK: ブラケット記法では、文字列として書くことができる
console.log(object["123"]); // => "value"
// NG: ドット記法では、数値からはじまる識別子は利用できない
object.123
```

オブジェクトはとても重要で、これから紹介する配列や正規表現もこのオブジェクトが元となっています。
詳細は「[オブジェクト][]」の章で解説します。
ここでは、オブジェクトリテラル（`{`と`}`）が出てきたら、新しいオブジェクトを作成しているんだなと思ってください。

### 配列リテラル {#array}

オブジェクトリテラルと並んで、よく使われるリテラルとして配列リテラルがあります。
配列リテラルは`[`と`]`で値をカンマ区切りで囲み、その値を持つArrayオブジェクトを作成します。
配列（Arrayオブジェクト）とは、複数の値に順序をつけて格納できるオブジェクトの一種です。

```js
const emptyArray = []; // 空の配列を作成
const array = [1, 2, 3]; // 値を持った配列を作成
```

<!-- textlint-disable prh -->

配列は`0`からはじまるインデックス（添字）に、対応した値を保持しています。
作成した配列の要素を取得するには、配列に対して`array[index]`という構文で指定したインデックスの値を参照できます。

<!-- textlint-enable prh -->


{{book.console}}
```js
const array = ["index:0", "index:1", "index:2"];
// 0番目の要素を参照
console.log(array[0]); // => "index:0"
// 1番目の要素を参照
console.log(array[1]); // => "index:1"
```

配列についての詳細は「[配列][]」の章で解説します。

### 正規表現リテラル {#regexp-literal}

JavaScriptは正規表現をリテラルで書くことができます。
正規表現リテラルは`/`（スラッシュ）と`/`（スラッシュ）で正規表現のパターン文字列を囲みます。
正規表現のパターン内では、`+`や`\`（バックスラッシュ）からはじまる特殊文字が特別な意味を持ちます。

次のコードでは、数字にマッチする特殊文字である`\d`を使い、1文字以上の数字にマッチする正規表現をリテラルで表現しています。

{{book.console}}
```js
const numberRegExp = /\d+/; // 1文字以上の数字にマッチする正規表現
// 123が正規表現にマッチするかをテストする
console.log(numberRegExp.test(123)); // => true
```

`RegExp`コンストラクタを使うことで、文字列から正規表現オブジェクトを作成できます。
しかし、特殊文字の二重エスケープが必要になり直感的に書くことが難しくなります。

正規表現オブジェクトについて詳しくは、「[文字列][]」の章で紹介します。

## プリミティブ型とオブジェクト {#primitive-and-wrapper-object}

<!--　textlint-disable preset-ja-technical-writing/max-ten -->

プリミティブ型は基本的にリテラルで表現しますが、真偽値（Boolean）、数値（Number）、文字列（String）はそれぞれオブジェクトとして表現する方法もあります。
これらはプリミティブ型の値をラップしたようなオブジェクトであるため**ラッパーオブジェクト**と呼ばれます。

ラッパーオブジェクトは、`new`演算子と対応するコンストラクタ関数を利用して作成できます。
たとえば、文字列のプリミティブ型に対応するコンストラクタ関数は`String`となります。

次のコードでは、`String`のラッパーオブジェクトを作成しています。
ラッパーオブジェクトは、名前のとおりオブジェクトの一種であるため`typeof`演算子の結果も`"object"`です。
また、オブジェクトであるため`length`プロパティなどのオブジェクトが持つプロパティを参照できます。

<!-- textlint-enable -->

{{book.console}}
```js
// 文字列をラップしたStringラッパーオブジェクト
const str = new String("文字列");
// ラッパーオブジェクトは"object"型のデータ
console.log(typeof str); // => "object"
// Stringオブジェクトの`length`プロパティは文字列の長さを返す
console.log(str.length); // => 3
```

しかし、明示的にラッパーオブジェクトを使うべき理由はありません。
なぜなら、JavaScriptではプリミティブ型のデータに対してもオブジェクトのように参照できる仕組みがあるためです。
次のコードでは、プリミティブ型の文字列データに対しても`length`プロパティへアクセスできています。

{{book.console}}
```js
// プリミティブ型の文字列データ
const str = "文字列";
// プリミティブ型の文字列は"string"型のデータ
console.log(typeof str); // => "string"
// プリミティブ型の文字列も`length`プロパティを参照できる
console.log(str.length); // => 3
```

これは、プリミティブ型のデータのプロパティへアクセスする際に、対応するラッパーオブジェクトへ暗黙的に変換してからプロパティへアクセスするためです。
また、ラッパーオブジェクトを明示的に作成するには、リテラルに比べて冗長な書き方が必要になります。
このように、ラッパーオブジェクトを明示的に作成する必要はないため、常にリテラルでプリミティブ型のデータを表現することを推奨します。

このラッパーオブジェクトへの暗黙的な型変換の仕組みについては「[ラッパーオブジェクト][]」の章で解説します。
現時点では、プリミティブ型のデータであってもオブジェクトのようにプロパティ（メソッドなども含む）を参照できるということだけを知っていれば問題ありません。

## まとめ {#data-type-summary}

この章では、データ型とリテラルについて学びました。

- 6種類のプリミティブ型とオブジェクトがある
- リテラルはデータ型の値を直接記述できる構文として定義されたもの
- プリミティブ型の真偽値、数値、文字列、nullはリテラル表現がある
- オブジェクト型のオブジェクト、配列、正規表現にはリテラル表現がある
- プリミティブ型のデータでもプロパティアクセスができる

<!-- 

## 参考 {#reference-for-data-type}

- [11.6.2 Reserved Words](http://www.ecma-international.org/ecma-262/7.0/#prod-ReservedWord "Reserved Words")
- [11.8.3.1Static Semantics: MV](http://www.ecma-international.org/ecma-262/7.0/#sec-static-semantics-mv "11.8.3.1Static Semantics: MV")
- [no-undefined - Rules - ESLint - Pluggable JavaScript linter](http://eslint.org/docs/rules/no-undefined "no-undefined - Rules - ESLint - Pluggable JavaScript linter")
    - `undefined`の宣言を禁止するESLintルール

-->

[^1]: JavaScriptが最初にNetscapeで実装された際に`typeof null === "object"`となるバグがありました。このバグを修正するとすでにこの挙動に依存しているコードが壊れるため、修正が見送られ現在の挙動が仕様となりました。 詳しくは<https://2ality.com/2013/10/typeof-null.html>を参照。
[IEEE 754]: https://ja.wikipedia.org/wiki/IEEE_754
[文字列]: ../string/README.md
[配列]: ../array/README.md
[オブジェクト]: ../object/README.md
[ラッパーオブジェクト]: ../wrapper-object/README.md
